{
  "title": "group",
  "text": "Свойство с типом group предназначено для группировки в себе части или всех контейнеров из какого либо виртуального массива.\r\nПри инициализации данного свойства htmlix ищет в html разметке контейнеры объявленные внутри него и добавляет их в поле groupChild, а также \r\nдобавляет ссылку на их виртуальный массив в поле groupArray.\r\n\r\nВ дальнейшем если понадобится добавить в группу новые контейнеры можно просто вызвать метод: \r\nsetProp({`container_prop1`: \"данные1\", `container_prop2`: \"данные2\", и т.д. }) - чтобы добавить контейнер в группу, либо setProp([ {`container_prop1`: \"данные1\", `container_prop2`: \"данные2\", и т.д. },  {`container_prop1`: \"данные1\", `container_prop2`: \"данные2\", и т.д. }]) - чтобы перезаписать группу. \r\n\r\n\r\nHtmlix создаст контейнеры для группы из массива который был сохранен  в свойство groupArray. Если при инициализации в свойстве с типом group не будет контейнеров, то соответственно ссылка на массив не будет создана, поэтому при добавлении новых контейнеров в группу htmlix попробует отискать ссылку на groupArray в свойствах group смежных контейнеров (если они не пустые) и если не найдет выдаст ошибку. Поэтому при создании свойства с типом group в нем либо должен быть контейнер который здесь будет отображаться либо шаблон template в свойстве group нулевого контейнера. Либо при использовании метода setProp напрямую указать виртуальный массив из которого брать шаблоны:\r\n```\r\nsetProp( {componentName: \"имя_виртуального_массива\", group: [ {container_prop1: \"данные1\", container_prop2: \"данные2\", и т.д. },  {container_prop1: \"данные1\", container_prop2: \"данные2\", и т.д. }] } );\r\n\r\n```\r\n\r\nОткрыв в консоли свойство с типом `group` можно увидеть следующие поля:\r\n\r\n* `groupArray` - ссылка на виртуальный массив контейнеров данной группы;\r\n* `groupChild` - группа контейнеров из виртуального массива, порядковый номер совпадает с полем groupId конкретного контейнера группы.\r\n\r\nТакже у свойства с типом `group` имеются дополнительные методы:\r\n\r\n* `.removeFromGroup(groupID)` - удаляет контейнер из группы а также из виртуального массива, где groupID - индекс контейнера в группе;\r\n* `.clearGroup()` -  удаляет все контейнеры из данного свойства а также из виртуального массива;\r\n* `.addToGroup(container, insertLocation)` - добавляет контейнер в группу и создает в нем поля **.groupId** - индекс группы, **.groupParent** - ссылка на свойство в котором находится контейнер\r\nгде container - сам контейнер, insertLocation - позиция для вставки, если не указать то вставит в конец группы;\r\n\r\n\r\n* `reuseGroup(arrayWithObjects)` - аналогичен reuseAll(arrayWithObjects) - только не для массива а для группы, единственная особенность его работы заключается в том,\r\nчто в свойстве должна быть ссылка на виртуальный массив данной группы this.groupArray если в данном свойстве ее нет, то он попытается отыскать ее в свойствах смежных контейнеров, если не найдет то не сработает.\r\nПоэтому при создании разметки, в свойстве с типом group нулевого контейнера, должен находиться контейнер который здесь будет отображаться, чтобы запомнить на него ссылку, если необходимо создать пустое свойство для всех контейнеров и только в процессе добавлять туда контейнеры, необходимо создать шаблон с типом \"template\" и (style=\"display: non\") для того чтобы запомнить ссылку на массив группы, либо использовать метод `.createNewGroup(groupArr, componentName)`\r\n* `.createInGroup(props, insertLocation)` - создает контейнер в виртуальном массиве и затем добавляет в группу на указанную позицию, если не указать добавит в конец, для работы требует наличие поля this.groupArray !=null\r\nкоторое добавляется при инициализации приложения. Поэтому при создании разметки, в свойстве с типом group нулевого контейнера, должен находиться контейнер который здесь будет отображаться, чтобы запомнить на него ссылку, \r\nесли необходимо создать пустое свойство для всех контейнеров и только в процессе добавлять туда контейнеры, необходимо создать шаблон с типом \"template\" и (style=\"display: non\") для того чтобы запомнить ссылку на массив группы. \r\n* `.createNewGroup(groupArr, componentName)` - если виртуальный массив данной группы this.groupArray.pathToComponent совпадает с именем `componentName` то вызывает метод `reuseGroup(groupArr)` , если не совпадает, удаляет все из группы и создает \r\nновую с контейнерами из виртуального массива `componentName`,  где `groupArr` - массив с объектами, ключи которых - имена свойств, а данные этих ключей, данные для свойств.\r\n\r\n\r\nВызов метода **setProp(val)** - в свойстве с типом group:\r\n* если val -объект с начальными данными для свойств в формате ключ - значение, вызовет метод `.createInGroup(val, insertLocation)`, insertLocation=val.location\r\n* если val - массив с объектами, ключами которых являются имена свойств - вызовет метод `reuseGroup(val)`\r\n* если val объект с полями `val.componentName`-имя виртуального массива, `val.group`- массив с объектами, ключами которых являются имена свойств - вызовет метод `.createNewGroup(val.group, val.componentName)`\r\n\r\nВызов метода **removeProp(val)**\r\n* если не передать параметр вызовет `.clearGroup()`\r\n* если передать вызовет `.removeFromGroup(val=groupID)`\r\n\r\nВызов метода **getProp()** возвращает массив с объектами ключами которых будут названия свойств, а значения,\r\n данные полученные из этих свойств на каждом контейнере, использует работает на основе метода getAllProps(),\r\n если передать параметром mapObject={key1: \"\", key2: {ke1: \"\"} } `.getProp(mapObject)`,\r\n вернет свойства только совпадающие по названиям с key, таким образом можно получить развернутый объект со всеми значениями свойств либо со всеми нужными значениями свойств из дочерних контейнеров; \r\n"
}