{
  "title": "Работа с пользовательскими событиями",
  "text": "В данной статье будут рассмотрены базовые принципы работы с пользовательскими событиями в Htmlix.\r\n\r\nДля понимания того зачем нужны пользовательские события давайте разберем ситуацию, когда например у нас есть три компонента которые отображают какую-то информацию на основе какой-то переменной. И форма в которой эта переменная изменяется и сохраняется в приложении:\r\n\r\n```html\r\n\r\n            <form data-form=\"container\" class=\"card col-12\" style=\"margin-bottom: 10px; margin-top: 10px; padding-bottom: 10px;\">\r\n\t\t\t\t\t<div class=\"form-group\">\r\n\t\t\t\t\t\t<label for=\"\">Введите имя</label>\r\n\t\t\t\t\t\t<textarea data-form-input=\"inputvalue\" class=\"form-control\" id=\"\" rows=\"1\"></textarea>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<button data-form-click=\"click\" type=\"submit\" class=\"btn btn-primary\">Submit</button>\r\n\t\t\t</form>\r\n\t\t\r\n\t\t\t<div data-test_container=\"container\" class=\"col-4 card\" style=\"color: red;\">\t\t\t\r\n\t\t\t\t<p>Привет: <span  data-test_container-text=\"text\">text</span></p>\r\n\t\t\t</div>\r\n\t\t\r\n\t\t\r\n\t\t   <div data-test_container_2=\"container\" class=\"col-4 card\" style=\"color: red; margin-top: 10px;\">\t\t\r\n\t\t\t\t<p>Вы вошли как: <span  data-test_container_2-text=\"text\">text</span></p>\t\t\t\r\n\t\t    </div>\r\n\t\t\t\r\n\r\n\t\t   <div data-test_container_3=\"container\" class=\"col-4 card\" style=\"color: red; margin-top: 10px;\">\t\t\t\r\n\t\t\t\t<p>Выйти из профиля(<span data-test_container_3-text=\"text\">text</span>)</p>\t\t\t\t\t\t\t\r\n\t\t   </div>\r\n\r\n``` \r\njavascript:\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n\t\r\n\tform: {\r\n\t\tcontainer: \"form\",\r\n\t\tprops: [\"input\", \"click\"],\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tclick: function(){\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tvar text = this.parent.props.input.getProp();\r\n\t\t\t\t\r\n\t\t\t\tconsole.log(text);\r\n\t\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t},\r\n\ttest_container: {\r\n\t\t\r\n\t\tcontainer: \"test_container\",\r\n\t\tprops: [ \"text\", ],\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t},\t\t\r\n\t},\r\n\ttest_container_2: {\r\n\t\t\r\n\t\tcontainer: \"test_container_2\",\r\n\t\tprops: [\"text\",],\r\n\t\tmethods: {\r\n\r\n\t\t},\t\t\r\n\t},\r\n\ttest_container_3: {\r\n\t\t\r\n\t\tcontainer: \"test_container_3\",\r\n\t\tprops: [\"text\",],\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t},\t\t\r\n\t},\r\n}\r\nwindow.onload = function(){\r\n\t\r\n\tvar HM = new HTMLixState(StateMap);\r\n\r\n\tconsole.log(HM);\r\n\t\r\n}\r\n\r\n\r\n```\r\nВ методе click формы мы записываем данные формы в переменную text. Теперь нам нужно отобразить новые данные в каждом из трех компонентов.\r\nМожно сделать это различными способами:\r\n\r\n* 1 в самом методе click напрямую перейти к каждому компоненту и установить свойство text:\r\n\r\n```\r\nclick: function(){\r\n\r\n\t\tevent.preventDefault();\r\n\t\tvar text = this.parent.props.input.getProp();\r\n                this.rootLink.state[\"test_container\"].props.text.setProp(text);\r\n                this.rootLink.state[\"test_container_2\"].props.text.setProp(text);\r\n                 this.rootLink.state[\"test_container_3\"].props.text.setProp(text);\r\n}\r\n\r\n```\r\nНедостаток данного подхода очевиден, что если потом мы где-нибудь еще будем получать данные для этого свойства? Например на основе cookie они будут загружаться автоматически.\r\n\r\n* 2 способ это создать метод в объекте stateMethods и вызывать его при изменении данных:\r\n\r\n```javascript\r\nststeMethods: {\r\n          \r\n         setName: function(text){\r\n\r\n                this.state[\"test_container\"].props.text.setProp(text);\r\n                this.state[\"test_container_2\"].props.text.setProp(text);\r\n                 this.state[\"test_container_3\"].props.text.setProp(text);\r\n\r\n       }\r\n\r\n}\r\n/* ---------при загрузке -------------*/\r\nwindow.onload = function(){\r\n              var name = getCookie(user_name); // где getCookie - какая-то  функция для получения cookie\r\n\r\n             if(name)HM.stateMethods.setName.call.(HM, name); ///вызываем метод передав ему контекст= HM\r\n}\r\n\r\n/*-------в форме------------------*/\r\n this.rootLink.stateMethods.setName.call.(this.rootLink, text); \r\n\r\n```\r\nВ данном случае нам удалось избежать дублирования кода, однако проблема в том что мы напрямую меняем свойство, произведя доступ к компоненту по его имени.\r\nЧто если мы потом захотим изменить имя компонента или вообще его удалить, или у нас будет много таких компонентов, а может перед тем как установить свойство его нужно как-то отформатировать, по разному для каждого компонента. Нам нужно будет редактировать код данного метода,  код станет плохо читаемым и тяжело поддерживаемым. Поэтому лучше когда каждый компонент сам работает со своими свойствами. Как это сделать в htmlix?  Для этого можно использовать пользовательские события.   Компонент подписывается на событие, и при его наступлении делает что-то со своими свойствами.\r\n\r\n* 3 использование пользовательских событий.\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n\t\r\n\tform: {\r\n\t\tcontainer: \"form\",\r\n\t\tprops: [\"input\", \"click\"],\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tclick: function(){\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tvar text = this.parent.props.input.getProp();\r\n\t\t\t\t\r\n\t\t\t\tthis.rootLink.eventProps[\"emiter-set-name\"].setEventProp(text); //вызвали событие из формы и передали в него новые данные \r\n\t\t\t\twindow.localStorage.setItem('user_name', text);\r\n\t\t\t\tconsole.log(text);\r\n\t\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t},\r\n\ttest_container: {\r\n\t\t\r\n\t\tcontainer: \"test_container\",\r\n\t\tprops: [ \"text\", ['listen_set_name', \"emiter-set-name\", \"\" ] ], //добавили слушателя события emiter-set-name компоненту \"test_container\"\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tlisten_set_name: function(){\r\n\t\t\t\t\r\n\t\t\t\tthis.parent.props.text.setProp( this.emiter.getEventProp() ); ///получили данные из события и обновили свойство компонента\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\t\t\r\n\t},\r\n\ttest_container_2: {\r\n\t\t\r\n\t\tcontainer: \"test_container_2\",\r\n\t\tprops: [ \"text\", ['listen_set_name', \"emiter-set-name\", \"\" ] ], //добавили слушателя события emiter-set-name компоненту \"test_container_2\"\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tlisten_set_name: function(){\r\n\t\t\t\t\r\n\t\t\t\tthis.parent.props.text.setProp( this.emiter.getEventProp() );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\t\r\n\t},\r\n\ttest_container_3: {\r\n\t\t\r\n\t\tcontainer: \"test_container_3\",\r\n\t\tprops: [ \"text\", ['listen_set_name', \"emiter-set-name\", \"\" ] ], //добавили слушателя события emiter-set-name компоненту \"test_container_3\"\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tlisten_set_name: function(){\r\n\t\t\t\t\r\n\t\t\t\tthis.parent.props.text.setProp( this.emiter.getEventProp() );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\t\t\r\n\t},\r\n\teventEmiters: { \r\n\t\t\r\n\t\t[\"emiter-set-name\"]: {prop: \"\"} ///создали эмитер пользовательских событий \"emiter-set-name\"\r\n\t\t\r\n\t}\r\n}\r\nwindow.onload = function(){\r\n\t\t\r\n\tvar HM = new HTMLixState(StateMap);\r\n\tvar name = window.localStorage.getItem('user_name');\r\n\t\r\n\tif(name != null)HM.eventProps[\"emiter-set-name\"].setEventProp(name); ///вызвали событие при загрузке сайта\r\n\r\n\tconsole.log(HM);\r\n\t\r\n}\r\n\r\n```\r\n\r\nТеперь если нам нужно изменить что-либо в компоненте,  или вообще удалить его нам не потребуется поправлять код в каждой функции, которых может быть сколько угодно. Таким образом компоненты у нас полностью инкапсулированы и чтобы отписаться от какого либо события нам нужно просто удалить слушателя в компоненте.\r\n\r\n\r\n<a href=\"https://sergeyovechkin.github.io/tests/test-eventProps/index.html\">Более реальный пример данного приложения</a>\r\n\r\n"
}