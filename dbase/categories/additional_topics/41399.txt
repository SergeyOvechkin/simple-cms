{
  "title": "Работа с пользовательскими событиями",
  "text": "В данной статье будут рассмотрены базовые принципы работы с пользовательскими событиями в Htmlix и создано небольшое приложение из четырех компонентов: формы ввода имени пользователя, приветствия, кнопки выхода из приложения, и массива с пользователями приложения. \r\n\r\nУже готовый пример можно покликать <a href=\"https://sergeyovechkin.github.io/tests/test-eventProps/index.html\">здесь</a>.\r\n\r\nПосле ввода имени пользователя в форму, приложение отобразит его имя в приветствии, кнопке выхода и создаст новый контейнер в массиве с пользователями, а также сохранит данные в localStorage. После перезагрузки страницы, возьмет имя из localStorage. При клике по кнопке \"выйти из профиля\" удалит данные со всех компонентов и переменную из localStorage.\r\n\r\nДавайте создадим четыре компонента: форму входа - form, приветствие - greeting, кнопку выхода - logout и массив со всеми посетителями - users_array, и посмотрим как бы мы создавали между ними коммуникацию если бы не пользовались пользовательскими событиями.\r\n\r\nСоздадим html разметку всех компонентов:\r\n\r\n```html\r\n\r\n <!--  компонент - контейнер форма с двумя свойствами input c типом свойства \"inputvalue\" и  click с типом \"click\" -->\r\n\r\n<form data-form=\"container\" class=\"card col-12\">\r\n   <div class=\"form-group\">\r\n       <label for=\"\">Введите имя</label>\r\n      <textarea data-form-input=\"inputvalue\" class=\"form-control\" rows=\"1\"></textarea>\r\n    </div>\r\n    <button data-form-click=\"click\" type=\"submit\">Submit</button>\r\n</form>\r\n\r\n\r\n<!-- компонент - контейнер приветствие и свойство user_name с типом - \"text\" -->\r\n\t\t\r\n<div data-greeting=\"container\" class=\"col-6 card\">\t\t\t\r\n    <p>Привет: <span  data-greeting-user_name=\"text\">guest</span></p>\r\n</div>\r\n\t\t\r\n\r\n<!-- компонент - контейнер кнопка выхода и свойство user_name с типом - \"text\" -->\r\n\t\t\r\n<div data-logout=\"container\" class=\"col-6 card\">\t\t\r\n      <a href=\"#\"> Выйти из профиля: ( <span  data-logout-user_name=\"text\"></span>  )\r\n      </a>\t\t\t\t\r\n</div>\r\n\t\t\t\r\n<!-- компонент - массив пользователей, изначально с двумя контейнерами, в каждом контейнере свойство user_name - \"text\"  --> \r\n\t\t\r\n<div class=\"container-fluid\" style=\"border: 1px solid red; margin-top: 20px;\">\r\n     <p> все пользователи:</p>\r\n\t\t \r\n      <div data-users_array=\"array\" class=\"row\">\r\n\t\t\r\n         <div data-user=\"container\" class=\"col-4 card\">\t\t\r\n\t     <p>пользователь - \r\n                    <span data-user-user_name=\"text\">user_name_1</span> \r\n            </p>\t\t\t\t\t\t\r\n\t</div>\r\n\r\n         <div data-user=\"container\" class=\"col-4 card\">\t\t\r\n\t     <p>пользователь - \r\n                    <span data-user-user_name=\"text\">user_name_1</span> \r\n            </p>\t\t\t\t\t\t\r\n\t</div>\r\n\t\t\t\t\t\t\t\t\t\r\n     </div>\t\r\n</div>\r\n\t\t\r\n```\r\n\r\nТеперь перенесем их в javascript:\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n\t\r\n\tform: {//форма входа\r\n\t\tcontainer: \"form\",\r\n\t\tprops: [\"input\", \"click\"],\r\n\t\tmethods: {\r\n\t\t\t\r\n\t\t\tclick: function(){\r\n\t\t\t\tevent.preventDefault(); //отменяем перезагрузку страницы\r\n\r\n                                 //получаем данные свойства input\r\n\t\t\t\tvar text = this.parent.props.input.getProp(); \r\n\t\t\t\tconsole.log(text);\t\t\t\t\t\t\t\r\n\t\t\t}\t\t\t\r\n\t\t},\t\t\r\n\t},\t\r\n\tgreeting: {//приветствие\r\n\t\t\r\n\t\tcontainer: \"greeting\",\r\n\t\tprops: [ \"user_name\", ], \r\n\t\tmethods: {\r\n\t        }\r\n\t},\r\n\tlogout: { //кнопка выхода\r\n\t\t\r\n\t\tcontainer: \"logout\",\r\n\t\tprops: [ \"user_name\", ], \r\n\t\tmethods: {\r\n\t\t},\t\r\n\t},\r\n\tusers_array: { //массив с пользователями \r\n\t\t\t\r\n\t\tcontainer: \"user\",\r\n\t\tprops: [ \"user_name\", ],\r\n\t\tmethods: {\t\t  \r\n\t\t},        \t\r\n\t},\r\n}\r\nwindow.onload = function(){//создаем экземпляр приложения htmlix\r\n\t\t\t\r\n\tvar HM = new HTMLixState(StateMap);\r\n\tconsole.log(HM);\t\r\n}\r\n\r\n```\r\n\r\nВ примере выше мы записали данные свойства \"input\" из компонента формы в переменную \"text\". Теперь нам нужно отобразить их в свойствах компонентов greeting и logout, а также создать новый контейнер в массиве users_array. Для понимания того зачем нужны пользовательские события давайте сначала попробуем сделать это различными способами без их использования.\r\n\r\n<b>1.</b> способ - в самом методе click формы напрямую перейти к каждому компоненту и установить свойство text:\r\n\r\n```javascript\r\n\r\n        event.preventDefault();\r\n        var text = this.parent.props.input.getProp();\r\n                //установили значения свойствам\r\n                this.rootLink.state[\"greeting\"].props.user_name.setProp(text);\r\n                this.rootLink.state[\"logout\"].props.user_name.setProp(text);\r\n                  \r\n                  ///создали новый контейнер\r\n                 this.rootLink.state[\"users_array\"].add({user_name: text});\r\n\r\n```\r\n\r\nНедостаток данного подхода очевиден, что если потом мы где-нибудь еще будем получать данные для этого свойства? Например на основе localstorage они будут загружаться автоматически.\r\n\r\n<b>2.</b> способ это создать метод в объекте stateMethods и вызывать его при изменении данных:\r\n\r\n```javascript\r\n\r\nstateMethods: {\r\n\r\n           //this в stateMethods методах указывает на rootLink\r\n         entryUser: function(text){\r\n\r\n                this.state[\"greeting\"].props.user_name.setProp(text);\r\n                this.state[\"logout\"].props.user_name.setProp(text);\r\n                 this.state[\"users_array\"].add({user_name: text});\r\n       }\r\n}\r\n\r\n// после загрузки страницы\r\nwindow.onload = function(){\r\n             var name = window.localStorage.getItem('user_name');\r\n\r\n             if(name)HM.stateMethods.entryUser(name); ///вызываем метод \r\n}\r\n\r\n//в форме\r\nclick: function(){\r\n                  event.preventDefault();\r\n                  var text = this.parent.props.input.getProp();\r\n                  this.rootLink.stateMethods.entryUser(text); \r\n}\r\n```\r\nВ данном случае нам удалось избежать дублирования кода, однако проблема в том что методы для работы со свойствами компонента находятся не внутри него а во внешних функциях. Что если перед тем как установить свойство его нужно как-то отформатировать, по разному для каждого компонента, или  нам нужно будет установить не одно свойство, а несколько, поэтому лучше когда компоненты сами работают со своими свойствами. \r\n\r\n<b>3.</b> способ - перенести всю логику работы со свойствами в компоненты, и создать в них методы, с помощью которых вызывать определенные действия.\r\n\r\n```javascript\r\n\t\r\n\tgreeting: {\r\n\t\t\r\n\t\tcontainer: \"greeting\",\r\n\r\n                //добавили вспомогательный метод для приветствия пользователя\r\n\t\tprops: [ \"user_name\", [\"greet_user\", \"aux\"] ], \r\n\t\tmethods: {\r\n                       \r\n                     greet_user: function(name){\r\n                                this.props.user_name.setProp(name+\" !!!\");\r\n                     }\r\n\t        }\r\n\t},\r\n\tlogout: { \t\t\r\n\t\tcontainer: \"logout\",\r\n\r\n\t\tprops: [ \"user_name\", [\"set_name\", \"aux\"]], //добавили вспомогательный метод для работы со свойством компонента\r\n\t\tmethods: {\r\n\r\n                     set_name: function(name){\r\n                                this.props.user_name.setProp(name);\r\n                     }\r\n                          \r\n\t\t},\t\r\n\t},\r\n\tusers_array: { \r\n\t\tarrayProps: [[\"entry_user\", \"aux\"]],  ///добавляем контейнер с новым пользователем из массива\r\n                arrayMethods: {\r\n                       entry_user: function(name){\r\n                              this.add({user_name: name})\r\n                       }\r\n               }\t\r\n\t\tcontainer: \"user\",\r\n\t\tprops: [ \"user_name\", ],\r\n\t\tmethods: {\t\t  \r\n\t\t},        \t\r\n\t},\r\n    stateMethods: {   //изменили общий метод          \r\n         entryUser: function(text){\r\n\r\n                this.state[\"greeting\"].methods.greet_user(text);\r\n                this.state[\"logout\"].methods.set_name(text);\r\n                this.state[\"users_array\"].methods.entry_user(text);\r\n        }\r\n   }\r\n   //далее также вызываем данный метод entryUser из формы и при загрузке страницы\r\n```\r\n\r\nТеперь компоненты инкапсулированы, однако  мы производим доступ к компоненту по его имени. Что если мы потом захотим изменить имя компонента или метода, или вообще удалить компонент, или у нас будет много таких компонентов которые слушают одно и тоже свойство. Или у нас будет много таких свойств, соответственно прийдется создавать много таких методов. \r\n\r\nЧтобы облегчить данную задачу можно воспользоваться пользовательскими событиями. Компонент подписывается на событие, и при его наступлении делает что-то со своими свойствами.\r\n\r\nДавайте отредактируем код, теперь с использованием пользовательских событий:\r\n\r\n```javascript\r\n\r\nvar StateMap = {\r\n\r\n   eventEmiters: {\t\r\n             //создали эмитер события - входа пользователя\t\r\n             [\"emiter-entry-user\"]: {prop: \"\"}, \t\t\r\n   },\r\n   form: {\r\n\tcontainer: \"form\",\r\n\tprops: [\"input\", \"click\"],\r\n\tmethods: {\r\n\t\t\t\r\n\t\tclick: function(){\r\n\t\t    event.preventDefault();\r\n\t\t    var text = this.parent.props.input.getProp();\r\n\r\n\t\t     //вызвали событие в форме и передали в него данные\r\n\t\t    this.rootLink.eventProps[\"emiter-entry-user\"].setEventProp(text); \t\r\n\t\t    window.localStorage.setItem('user_name', text);\t\t\t\t\t\t\t\r\n\t\t}\t\t\t\r\n\t},\t\t\r\n},\t\r\ngreeting: {\r\n\t\t\r\n\tcontainer: \"greeting\",\r\n\tprops: [ \"user_name\", ['listen_entry_user', \"emiter-entry-user\", \"\" ] ], //добавили слушатель события \"emiter-entry-user\"\r\n\tmethods: {\r\n\t\t\t\r\n\t\tlisten_entry_user: function(){\r\n\t\t   //получили данные из события и обновили свойство\r\n\t\t   this.parent.props.user_name.setProp( this.emiter.getEventProp() );\r\n\t\t},\t\r\n\t},\t\t\r\n},\r\nlogout: { \r\n\t\t\r\n\tcontainer: \"logout\",\r\n\tprops: [ \"user_name\", [\"listen_entry_user\", \"emiter-entry-user\", \"\" ]], //свойство слушатель события \"emiter-entry-user\"\r\n\tmethods: {\r\n\t\t\t\r\n\t\tlisten_entry_user: function(){\r\n\t\t     //получили данные из события и обновили свойство \r\n\t\t     this.parent.props.user_name.setProp( this.emiter.getEventProp() );\r\n\t\t},\t\t\t\r\n\t},\t\r\n},\r\n    //здесь слушатель события добавляется в свойство массива, т.к. если добавить его в контейнер оно будет вызвано для каждого контейнера \r\nusers_array: { \r\n\t\t\r\n\tarrayProps: [ ['listen_entry_user', \"emiter-entry-user\", \"\"] ], //свойство слушатель события \"emiter-entry-user\"\r\n\t   arrayMethods: {\r\n\t\t\t\r\n\t\tlisten_entry_user: function(){\r\n\t\t\t//получили данные из события и создали новый контейнер\r\n\t\t\tthis.parent.add( {user_name: this.emiter.getEventProp()} );\r\n\t\t},\t\t\t\r\n\t},\t\t\r\n\tcontainer: \"user\",\r\n\tprops: [ \"user_name\",  ['listen_exit_user', \"emiter-exit-user\", \"\"]  ],\r\n\tmethods: {\t\t\t\t\t\t\r\n\t\t}\r\n\t},        \t\r\n},\r\n\r\n}\r\nwindow.onload = function(){\r\n\t\r\n\t\t\r\n\tvar HM = new HTMLixState(StateMap);\r\n\tvar name = window.localStorage.getItem('user_name');\r\n\t\r\n\tif(name != null)HM.eventProps[\"emiter-entry-user\"].setEventProp(name); ///вызвали событие \"emiter-entry-user\" при загрузке сайта и передали в него данные\t\r\n}\r\n```\r\nТаким образом мы избавились от промежуточного метода \"entryUser\" и просто вызываем событие передав в него новые данные в форме и после загрузки страницы. Теперь если нам нужно изменить что-либо в компоненте, или вообще удалить его нам не потребуется поправлять код в каждой функции, которых может быть сколько угодно. А чтобы отписаться от какого либо события можно просто удалить слушателя в компоненте, или временно отключить его с помощью метода disableEvent() в свойстве - подписчике.\r\n\r\nПолный код данного примера вместе со вторым событием \"emiter-exit-user\" можно посмотреть <a href=\"https://github.com/SergeyOvechkin/tests/tree/master/test-eventProps\">здесь</a>.\r\n\r\n"
}