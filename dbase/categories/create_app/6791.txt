{
  "title": "Создание прототипа SPA интернет магазина",
  "text": "В этом разделе будет описано пошаговое создание простого прототипа фронтенда SPA интернет магазина. Серверная часть которого написана на node.js с использованием express,  шаблонизатора - twig ,  базы данных - NeDB ,  для обработки данных форм - модуль formidable , клиентская часть  написана на htmlix.\r\n\r\nИсходные данные для данного урока можно скачать <a href=\"https://github.com/SergeyOvechkin/lesson_2.2\"> здесь </a>\r\n\r\nЭто уже готовый пример мы просто удалим из файла `/static/js/front.js` все что там есть и вставим вместо этого:\r\n```javascript\r\nvar State = {\t\r\n}\r\n\twindow.onload = function(){\r\n\t\t\t///создаем экземпляр  HTMLix\r\n\t\t\t\r\n\t\tvar HM = new HTMLixState(State);\r\n\t        console.log(HM);\r\n\t}\r\n```\r\nИтак мы полностью удалили фронтенд из данного примера, и у нас остался сервер приложения, давайте разберемся как он работает:\r\n\r\n* сперва нужно установить все модули которых сейчас нет, для этого введем в консоли: `npm install`\r\n* далее ввести в командной строке `node app`\r\n* затем перейти по адресу `localhost:3000`\r\n\r\nИтак покликав по различным пунктам меню мы видим работающий сервер, без фронтенд части т.к. мы только что ее удалили.\r\nТеперь заново поэтапно ее создадим, но для начала разберемся как работает сервер.\r\n\r\nПерейдя по адресу `\"/\"` нам отдается верхнее меню с тремя пунктами, основная страница с шестью карточками товара, и список категорий с левой стороны.\r\n\r\nЧтобы отдать нам это все сервер посылает два запроса к базе данных, в одном он находит все категории, во втором первые шесть карточек товара из таблицы, затем присоединяет к каждой карточке товара два поля из совпадающей по id категории товара, затем отдает нам представление  `/views/index.twig` передав в него массив с категориями - `categories` и массив с карточками товара `carts`.\r\n\r\nДалее в самом представлении `/views/index.twig` мы загружаем из папки `/twig_templates` шапку сайта и верхнее меню:\r\n\r\n`{% include  '/twig_templates/header.twig' %}`\r\n\r\nДалее создаем разметку для главной страницы и страницы категорий, в ней создаем список категорий из переданого с сервера массива `categories`:\r\n```html\r\n<section class=\"categories\" >\r\n   <ul class=\"nav flex-column\" data-categories=\"array\">\r\n     {% for category in categories %}\r\n\t<li  class=\"nav-item\" data-category=\"container\">\r\n\t   <a {% if activeCategory == category.idCategory %}\r\n\t\tclass=\"nav-link active\" \r\n\t      {% else %}\r\n\t\t class=\"nav-link\" \r\n\t      {% endif %} \r\n\t     data-category-click=\"click\" data-category-title=\"text\" data-category-class=\"class\" data-category-data=\"{{ category.idCategory }}\" class=\"nav-link\" href=\"/category/{{ category.idCategory }}\">{{ category.titleCategory }}</a>\r\n\t</li>\r\n      {% endfor %}\r\n   </ul>\r\n</section>\r\n```\r\nПока что не обращаем внимания на записи в теге начинающиеся с data- все это относится к фронтенду и нам пока что не интересно.\r\n\r\nДалее в цикле создаем все карточки товара из массива `carts`:\r\n\r\n```\r\n\r\n{% for cart in carts %}\r\n   <div data-cart=\"container\" class=\"col-12 col-sm-6  col-lg-4\">\r\n\t<div  class=\"card\" style=\"margin-bottom: 10px;\">\r\n\t   <img data-cart-src_img=\"src\" src=\"/static/upload/{{cart.image}}\" class=\"card-img-top\" alt=\"...\">\r\n\t   <div class=\"card-body\">\r\n\t\t<h5 data-cart-title=\"text\" class=\"card-title\">{{cart.title}}</h5>\r\n\t\t<h6 data-cart-title_category=\"text\" class=\"card-subtitle mb-2 text-muted\">\r\n                        {{cart.titleCategory}}\r\n                 </h6>\r\n\t\t<div class=\"row justify-content-between\">\r\n\t\t    <div class=\"col-6\">\r\n\t\t\t<h5 data-cart-cost=\"text\" class=\"card-title\">{{cart.cost}}</h5>\r\n\t\t   </div>\r\n\t\t   <div class=\"col-6\" style=\"padding-right: 0px;\">\r\n\t\t\t<a data-cart-click=\"click\"  data-cart-data=\"/cart/{{cart._id}}\" href=\"/cart/{{cart._id}}\" class=\"btn btn-primary btn-sm\">Смотреть</a>\r\n\t\t   </div>\t\t\t\t\t\t\t\t\t\t\r\n\t        </div>\r\n\t   </div>\r\n\t</div>\r\n     </div>\r\n{% endfor %}\r\n\r\n```\r\nЗатем в самом конце мы загружаем footer, в котором подключаем htmlix.js и frontend.js - наш файл с фронтендом:\r\n\r\n`{% include  '/twig_templates/footer.twig' %}`\r\n\r\nАналогично для адреса `http://localhost:3000/category/:idCategory` мы также загружаем все категории, затем ищем карточки товара для данной категории а потом также передаем все это в представление `/views/index.twig`.\r\n\r\nТакже давайте сразу рассмотрим два адреса: `'/json'` и `/category/:idCategory/json` перейдя по этим адресам мы получим вместо представления массив с карточками товара в формате json, для первого адреса это первые шесть карточек, а для второго карточки соответствующей категории - `:idCategory`.\r\n\r\nТеперь разберем маршрут `\"/cart/:idCart\"` \r\n\r\nЗдесь мы также загружаем все категории, затем одну карточку соответствующую `:idCart` затем также присоединяем ей два поля из таблицы категорий, затем отдаем представление `'/views/cart.twig'` передав в него карточку - cart и массив с категориями categories.\r\n\r\nДалее в представлении также подключаем '/twig_templates/header.twig'. Подключаем header, затем создаем список категорий из массива categories.\r\n\r\nСоздаем разметку для карточки товара, в ней мы вставляем данные из объекта cart, а также подключаем один из двух вариантов шаблона из папки `/twig_templates/`: `cart_variant_option.twig` или `cart_variant_radio.twig` который мы выбрали при создании категории товара.\r\n\r\n```\r\n<div class=\"col-md-5\"   data-cart_single-variant_tmpl=\"render-variant\">\r\n\t\t\t\t\t\t\r\n\t{% set templ = cart.variant_tmpl %}\t\r\n<!-- создали переменную set templ  на основе свойства объекта cart.variant_tmpl -->\t\t\t\r\n\t\t\t\t\t\r\n\t{% include  '/twig_templates/' ~ templ ~ '.twig' %} \r\n<!-- динамически вставили шаблон из папки '/twig_templates/' на основании переменной с именем шаблона  templ -->\r\n\r\n</div>\r\n\r\n```\r\nВ конце разметки подключаем footer.\r\n\r\nМаршрут `\"/cart/:idCart/json\"` отдает пустой массив [], данный роут используется для заглушки.\r\n \r\n\r\nИтак мы достаточно знаем о сервере чтобы начать строить приложение пока что для трех роутов.\r\n\r\nДавайте сначала разберемся с роутами `\"/\"` и `\"/category/:idCategory\"`:\r\n\r\nЗдесь страницу можно разделить на два компонента это категории и карточки товара, давайте создадим два компонента в описании приложения это: categories, carts:\r\n\r\nВ html коде файла `/views/index.twig` они уже обозначены как data-carts=\"array\" - компонент carts, `data-cart`=\"container\" - контейнер cart компонента carts. `data-categories`=\"array\" - компонент categories, `data-category`=\"container\" - контейнер category компонента categories.\r\n\r\n```javascript\r\nvar State = {\r\n\t\r\n\tcategories: { //компонент категории\r\n\t\tcontainer: \"category\", //контейнер компонента категории\r\n\t\tprops: [ ],\r\n\t\tmethods: {\r\n\r\n\t\t}\t\t\r\n\t},\r\n\tcarts: { //компонент карточки товара\r\n\t\tcontainer: \"cart\", //контейнер компонента карточки товара\r\n\t\tprops: [ ],\r\n\t\tmethods: {\t\t\t\r\n\t\t}\t\t\r\n\t}\t\r\n}\r\n```\r\n\r\nИтак мы создали два компонента давайте добавим несколько свойств для компонента  categories: \r\n\r\n* `\"data\"` - данные которые содержат idCategory ( {{ category.idCategory }} ), \r\n* `\"click\"`- обработчик кликов по категории,\r\n* `'class'` - доступ к классу категории для изменения цвета текущей категории,\r\n*  `\"title\"` - доступ к тексту внутри категории ( {{ category.titleCategory }} ), \r\n\r\nВ html коде файла `/views/index.twig` они уже обозначены как data-category-data=\"{{ category.idCategory }}\", data-category-click=\"click\", data-category-class=\"class\", data-category-title=\"text\".\r\n\r\n\r\nДобавим их в описание приложения:\r\n\r\n```javascript\r\n\tcategories: {\r\n\t\tcontainer: \"category\", \r\n\t\tprops: [ \"data\", \"click\", 'class', \"title\"],\r\n\t\tmethods: {\r\n\t\t  click: function(){\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tevent.preventDefault();\t\t\t\t\r\n                               console.log(this);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t},\r\n\t\t}\t\t\r\n\t},\r\n ```\r\n\r\nИтак мы создали четыре свойства для каждого контейнера категории, и для свойства \"click\" метод который пока что ничего  не делает, только отменяет переход по ссылке и перезагрузку страницы. Давайте разберемся что нам нужно сделать при клике по категории:\r\n\r\n* 1 - загрузить массив с карточками товара для дальнейшего использования, чтобы построить компонент carts на основании полученных данных.\r\n* 2 - удалить класс .active у предыдущей и установить у новой категории.\r\n\r\nДля первого пункта создадим метод `load_carts` в общих для всего приложения методах `stateMethods` и поместим загруженные карточки в переменную `carts` объекта `stateProperties` - общих для всего приложения переменных;\r\n\r\nДля второго пункта создадим пользовательское событие \"emiter-click-on-category\" и будем слушать его во всех контейнерах category чтобы добавить или удалить класс при его наступлении, вызывать событие будем в методе click контейнера category.\r\n\r\n\r\nИзменим описание приложения:\r\n```javascript\r\nvar State = {\r\n\t\r\n  categories: {\r\n    container: \"category\", \r\n    //добавили слушателя события \"emiter-click-on-category\"\r\n    props: [ \"data\", \"click\", 'class', \"title\",  ['listner_click_on_category', \"emiter-click-on-category\", \"\"]],\r\n    methods: {\r\n\tclick: function(){\r\n\t\t\t\t\t\t\t\t\r\n\t   event.preventDefault();\r\n\t   var categoryId = this.parent.props.data.getProp(); \t\t\r\n\t   //вызываем событие \"emiter-click-on-category\"\r\n           // передав в него данные со свойства data контейнера по которому был клик\r\n\t    this.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(categoryId);\r\n\t\t\t\t\r\n\t    //создаем url на основе данных со свойства data контейнера,\r\n\t    //один для истории - historyUrl понадобится нам в дальнейшем,\r\n           // второй чтобы сделать запрос для получения карточек товара на адрес /category/:idCategory/json\r\n\t    \r\n           var historyUrl = \"/category/\"+categoryId;\r\n\t    var url = historyUrl+\"/json\";\t\t\t\t\r\n           \r\n           this.rootLink.stateMethods.load_carts(url, this);\r\n\t\t\t\t\t\t\t\t\r\n\t},\r\n\tlistner_click_on_category: function(){ \r\n\t//в слушателе события клика по категории удаляем класс \"active\" со всех контейнеров\r\n\t// затем устанавливаем его на контейнере данные свойства data которого совпадают\r\n        // с данными переданyыми в событие \"emiter-click-on-category\"\r\n\t\t\t\t\r\n\t\tthis.parent.props.class.removeProp(\"active\");\r\n\t\t\t\t\r\n\t\tif(this.parent.props.data.getProp() == this.emiter.prop){\t\t\t\t\t\r\n\t\t  this.parent.props.class.setProp(\"active\");\r\n\t\t}\t\t\t\t\r\n\t},\r\n      }\t\t\r\n    },\r\n```\r\n```javascript\r\n    carts: {\r\n\tcontainer: \"cart\",\r\n\tprops: [ ],\r\n\tmethods: {\r\n\t\t\t\r\n\t}\t\t\r\n     },\r\n     stateProperties:{ //объект для хранения общих переменных приложения\t\t\r\n\tcarts: [],\t\t\r\n     },\r\n     stateMethods: {\r\n\tfetchCategoryCarts: function(url, callb){ \r\n\t// общий  метод для загрузки данных с какого либо адреса get запросм, \r\n       //принимает в параметрах адрес - url и функцию обратного вызова callb,\r\n      // в которую он передаст полученные данные \r\n\t\t\t\t\t\r\n\t   fetch(url).then((response) => {\r\n\t\tif(response.ok) {\r\n\t\t   return response.json();\r\n\t\t}\t          \r\n\t\t  throw new Error('Network response was not ok');\r\n\t    }).then((json) => {\r\n\t\tcallb(json); \r\n            }).catch((error) => {\r\n\t\t console.log(error);\r\n\t     });\t\r\n\t}, \r\n\tload_carts:  function(url, context ){ \r\n\t//метод вызывает fetchCategoryCarts передавая в него функцию обратного вызова \r\n\t// в которой подставляем данные с сервера в переменную .carts\r\n\t//в дальнейшем также будем вызывать событие \"emiter-load-carts\" которое мы еще не создали\r\n\r\n\t   context.rootLink.stateMethods.fetchCategoryCarts(url, function(data){\r\n\t\t\t\t\t\r\n\t       context.rootLink.stateProperties.carts = data;\r\n\t\t\t\t\t\r\n\t       console.log(data)\r\n\t      //context.rootLink.eventProps[\"emiter-load-carts\"].setEventProp(data);\t\t\t\t\r\n\t\t\t\t\t\r\n\t    });\r\n\t},\r\n\r\n     },\r\n     eventEmiters: {//создали объект со всеми пользовательскими событиями\r\n\t\t \r\n           [\"emiter-click-on-category\"] : { //добавили событие \"emiter-click-on-category\"\t\t\t\t\r\n\t\tprop: [],\t\t\t\t\r\n\t   },\r\n      }\t\t\r\n}\r\n\t\t\r\n```\r\nИтак теперь при клике по категории у нас меняется класс текущей категории с помощью события \"emiter-click-on-category\", а также загружаются данные с сервера с помощью метода `load_carts` объекта stateMethods, которые мы сохраняем в свойстве carts объекта stateProperties и выводим пока что в консоль.\r\n\r\nДалее давайте добавим свойства контейнера `cart` компонента `carts` : \r\n'title', \"title_category\",  \"cost\", \"click\", \"src_img\", \"data\"\r\n* `\"data\"` - данные которые содержат '/cart/:idCart' ( \"/cart/{{cart._id}}\" ), \r\n* `\"title_category\"`- название категории {{cart.titleCategory}},\r\n* `\"cost\"` - стоимость товара {{cart.cost}},\r\n*  `'title'` - доступ к тексту внутри карточки ( {{cart.title}} ),\r\n* `\"src_img\"` - адрес картинки карточки \"/static/upload/{{cart.image}}\",\r\n* `\"click\"` - обработчик события клика по карточке товара,\r\n\r\nа также создадим дополнительное свойство массива `carts` - `'listener_load_carts'` которое будет слушать событие \"emiter-load-carts\" - загрузки карточек товара, мы его будем вызывать в методе `load_carts` объекта stateMethods.\r\n\r\nТеперь добавим все свойства к нашему компоненту `carts`:\r\n\r\n```javascript\r\n carts: {\r\n    //добавили свойство listener_load_carts для массива carts\r\n     arrayProps: [ ['listener_load_carts', \"emiter-load-carts\", \"\"] ],\r\n     arrayMethods: { \t\t\r\n        listener_load_carts: function(){ //слушаем событие \"emiter-load-carts\"\r\n\r\n\t     this.parent.removeAll(); //очищаем массив\r\n\r\n             var carts = this.emiter.prop;\r\n\r\n\t     for(var i=0; i<carts.length; i++){\r\n\t\t //в цикле перебираем полученный массив с карточками товара\t\r\n\t\t\t\t\t\t\r\n\t\t var cart = carts[i];\r\n\t\t\t\t\t\t\r\n\t\t   var props = { //создаем объект со всеми свойствами для контейнера cart\r\n\t\t\t\t\t\t\t\r\n\t\t\ttitle: cart.title,\r\n\t\t\ttitle_category: cart.titleCategory,\r\n\t\t\tcost: cart.cost,\r\n\t\t\tsrc_img: '/static/upload/'+cart.image,\r\n\t\t\tdata: \"/cart/\"+cart._id\r\n\t\t   }\r\n\t\t\t\t\t\t\r\n\t\tthis.parent.add(props); \r\n                //добавляем новый контейнер передав в него начальные данные для свойств\r\n\t    }\r\n\t}\r\n    },\r\n    container: \"cart\",\r\n    //добавили все свойства для контейнера cart\r\n\tprops: ['title', \"title_category\",  \"cost\", \"click\", \"src_img\", \"data\"  ],\r\n\tmethods: {\r\n\t     click: function(){ //метод для обработки кликов по карточке товара, \r\n\t\t\t\t//пока что просто выводит url карточки в консоль\r\n\t\t\t\t\r\n\t\t event.preventDefault();\t\t\t\t\r\n\t\t var url = this.parent.props.data.getProp();\r\n\t\t  console.log(url);\t\t\t\t\r\n\t     }\r\n\t  }\t\t\r\n },\r\n```\r\nТакже не забудем раскоментировать вызов события \"emiter-load-carts\" в методе `load_carts` и добавить новое событие в объект eventEmiters:\r\n\r\n```javascript\r\n\r\nload_carts:  function(url, context ){ \r\n\r\n\t   context.rootLink.stateMethods.fetchCategoryCarts(url, function(data){\t\t\t\t\r\n\t       context.rootLink.stateProperties.carts = data;\r\n\t\t\t\t\t\r\n\t        console.log(data)\r\n\t        context.rootLink.eventProps[\"emiter-load-carts\"].setEventProp(data);\t\t\t\t\r\n\t\t//раскомментировали вызов события \"emiter-load-carts\" \r\n\t\t//теперь мы передаем в него массив carts полученный с сервера,\r\n                // в обработчике события их можно будет получить вызвав this.emiter.prop \t\r\n\t    });\r\n\t},\r\n\r\n   ///*********************************************\r\n   eventEmiters: {\r\n           // ------------------------------\t\t \r\n\t   [\"emiter-load-carts\"]: { //добавили новое событие\r\n\t\t\t\r\n\t\t\tprop: \"\",\r\n\t     }\r\n      }\t\r\n\r\n\r\n```\r\nНу вот теперь при клике по категории у нас загружаются данные с сервера и отображаются в компоненте carts, однако при клике по карточке товара пока что ничего не происходит, кроме вывода в консоль адреса просматриваемой карточки `/cart/:idCart` \r\n\r\nДалее создадим компонент карточку товара `cart_single`, но прежде чем ее создать разберемся как работает htmlix:\r\n\r\nИтак при загрузке страници с адреса \"/\" либо \"/category/:idCategory\", сервер присылает нам html код двух компонентов, точнее трех, еще \"menu\", но его мы пока что не используем, мы используем html код для компонентов carts и categories, на основе этого кода htmlix создает шаблоны для компонентов, но шаблон для компонента `cart_single` нам не передается по данным адресам, т.к. его там нет. Как же нам его \"догрузить\" ? Дела обстоят следующим образом, мы создаем компонент `cart_single` в описании приложения и помещаяем его в специальный объект `\"fetchComponents\"` а в настройках `stateSettings.templatePath` \r\nуказываем адрес по которому загружать шаблоны для данного компонента, да и всех остальных, которые еще появятся. Таким образом приложение сначала создаст компоненты которые прислал сервер вместе с html, а затем после отправки второго запроса\r\nпо адресу stateSettings.templatePath создаст остальные компоненты, находящиеся в объекте fetchComponents.\r\n\r\nТак бы мы сделали если бы вход в приложения у нас всегда бы был с адресов,  \"/\" либо \"/category/:idCategory\", а что если мы потом первую загрузку приложения произведем с адреса `\"/cart/:idCart\"` ? Приложение выдаст ошибку, что не может найти шаблон для массива carts, так как теперь его не будет по этому адресу и нам нужно помещать теперь carts в объект `\"fetchComponents\"` a `single_cart` наоборот оттуда достать, т.к. он должен инициализироваться первым вместе с компонентом categories, что же делать?\r\n\r\nДля решения этой задачи мы будем использовать `HTMLixRouter()`, он перед тем как создать экземпляр приложения, после загрузки страницы проверяет какой сейчас адрес url и сравнивает его с теми которые мы ему укажем, и затем сам помещает те для которых нет шаблона в первой загрузке, в объект `\"fetchComponents\"`, после чего инициализирует приложение, таким образом мы избежим создания, нескольких вариантов описания приложения для разных url и соответственно дублирования кода.\r\n\r\nИтак у нас пока что есть три адреса \"/\" ,\"/category/:idCategory\" и \"/cart/:idCart\", три основных компонента carts, categories и `cart_single`. На первых двух адресах у нас первыми должны инициализироваться компоненты carts и categories, а на адресе  \"/cart/:idCart\" -   categories и cart_single. \r\n\r\nИтак создадим для них объект routes и поместим его отдельно он писания приложения State в переменную :\r\n```javascript\r\nvar routes = {\r\n\t\r\n    [\"/\"]: {\t\t\r\n        first: [\"categories\", 'carts'],  /// компоненты которые есть в html файле указываются в этом массиве, остальные будут загружены с шаблона, в fetch запросе асинхронно\r\n\r\n\troutComponent: { \r\n                router_carts: \"carts\", //компонент соответствующий данному роуту\r\n           }, \r\n\t\ttemplatePath: \"/static/templates/index.html\" // папка для загрузки шаблонов\r\n     },\t\t\t\r\n     [\"/category/:idCategory\"]: {  //знак `:` говорит что это параметр, и с ним сравненние не требуется, проверяется только его наличие, еще есть знак `*` в конце слова например если у нас category1, category2, и т.д то ставим звездочку в конце category*.\r\n\t\t\r\n\t first: [\"categories\", 'carts', \"menu\", \"home_page\"], \r\n\r\n\t routComponent: {\t\t\t\r\n\t         router_carts: \"carts\",\t\t\t\r\n\t\t}, \r\n\t  templatePath: \"/static/templates/index.html\" \r\n\t},\t\r\n     [\"/cart/:idCart\"]: { \r\n\t\t\r\n\t  first: [\"categories\", 'cart_single'], \r\n\r\n\t  routComponent: {\r\n\t       router_carts: \"cart_single\",\t\t\t\r\n\t   },\r\n\t   templatePath: \"/static/templates/index.html\"\r\n      },\r\n}\r\n\r\n```\r\n\r\nИтак мы создали три маршрута для роутера, здесь `router_carts` это div элемент в котором будут отображаться  \"carts\" на первых двух адресах, а на третьем \"cart_single\", в html (в файлах `/views/index.twig` и `'/views/cart.twig'`) он указан как `data-router_carts=\"router\"`. \r\n\r\n\r\nДалее добавим в описание приложения `cart_single` вместе со следующими свойствами:\r\n* `\"variant_tmpl\"` - свойство с типом \"render-variant\" для отображения дополнительного варианта шаблона (cart_variant_option.twig или cart_variant_radio.twig в зависимости от категории) в html коде data-cart_single-variant_tmpl-\"render-variant\",\r\n* `'title'` - Название карточки товара 'data-cart_single-title=\"text\"', \r\n* `\"title_category\"` название категории,\r\n* `\"manufacture\"` - призводитель,\r\n* `\"cost\"` - стоимость,\r\n* `\"description\"` - описание,\r\n* `\"cost_btn\"` стоимость в кнопке,\r\n* `\"src_img\"` картинка data-cart_single-src_img=\"srс\", \r\n* `\"data\"` - данные с id категории для формирования url - data-cart_single-data=\"{{ cart.category }}\",\r\n* `\"click_category\"` - событие клика по категории в карточке товара,\r\n* ` \"listner_click_on_cart\"`  слушатель пользовательского события - \"emiter-click-on-cart\", \r\n\r\n\r\n```\r\ncart_single: {\r\n   container: \"cart_single\",\r\n   //пока что закомментируем \"variant_tmpl\" т.к. мы еще не создали варианты шаблонов для карточки\r\n   props: ['title', \"title_category\", \"manufacture\", \"cost\", \"description\", \"cost_btn\", \"src_img\", [\"listner_click_on_cart\", \"emiter-click-on-cart\", \"\"], \"click_category\", \"data\"],\r\n   methods: {\r\n\t\t\t\r\n\tlistner_click_on_cart: function(){\r\n\t\t\t\t\r\n\t\tvar index = this.emiter.getEventProp(); \r\n                 //получаем индекс контейнера карточки по которой кликнули в компоненте carts\r\n\r\n\t\tvar cart = this.rootLink.stateProperties.carts[index];\r\n                //выбираем из загруженных раннее в массиве карточек нужную нам по индексу контейнера \r\n\t\t\t\t\r\n\t\tvar props = {\r\n\t\t\t\t\t\t\t\r\n\t\t   title: cart.title,\r\n\t\t   title_category: cart.titleCategory,\r\n\t\t   cost: cart.cost,\r\n\t\t   src_img: '/static/upload/'+cart.image,\r\n\t\t   data: cart.category,\r\n\t\t   description:  cart.description,\r\n\t\t   cost_btn: cart.cost,\r\n\t\t   manufacture: cart.manufacture,\r\n\t\t  // variant_tmpl: cart.variant_tmpl, пока что закоментируем установку варианта шаблона, т.к. мы еще не создали компоненты для них.\r\n\t\t\t\t\t\t\t\r\n\t\t }\r\n\t\t\t\t\t\t\r\n\t\tthis.parent.setAllProps(props);\r\n \t        //устанавливаем новые значения сразу для всех свойств, с помощью метода setAllProps(props);\t\t\t\t\t\r\n\t},\r\n\tclick_category: function(){\r\n\t   event.preventDefault(); \r\n           //данный метод создадим чуть позже, пока что просто выводим id категории в консоль\r\n           console.log(this.parent.props.data)\t\t\t\t\r\n\t }\t\r\n      },\r\n},\r\n\r\n``` \r\nДалее добавим в метод `click` контейнера 'cart' компонента `carts` дополнительный код\r\n\r\n```\r\nclick: function(){  \r\n\t\t\t\t               \r\n   event.preventDefault();\t\t\t\t\r\n   var url = this.parent.props.data.getProp(); //в свойстве data контейнера cart у нас url крточки товара. \r\n\r\n    //добавили вызов события  \"emiter-click-on-cart\"  которое мы слушаем в компоненте single_cart и обновляем данные всех свойств\r\n    //передаем в него индекс контейнера по которому кликнули\r\n    this.rootLink.eventProps[\"emiter-click-on-cart\"].setEventProp(this.parent.index);\r\n   \r\n   //вызываем метод setRout передав в него новый url,\r\n   // чтобы роутер поменял компонент carts на cart_single в div элементе с data-router_carts=\"router\"  \r\n\r\n    this.rootLink.router.setRout(url);\t\t\t\t\r\n}\r\n\r\n```\r\nДалее добавляем новое событие \"emiter-click-on-cart\" в объект eventEmiters\r\n\r\n```\r\n     eventEmiters: {\r\n\t \r\n\t \t [\"emiter-click-on-cart\"]: {\r\n\t\t\t\r\n\t\t\tprop: \"\",\r\n\t\t},\t\r\n```\r\nА также в конец метода click контейнера catgory компонента categories:\r\n\r\n```javascript\r\nclick: function() {\r\n    \r\n    //метод setRout принимает url и сравнивает его с картой которую мы создали в объекте routes\r\n    //и на соответствующем адресе меняет компонент в div теге с `data-router_carts=\"router\"` отображая carts или single_cart\r\n     /* ............ конец метода ............*/\r\n     this.rootLink.router.setRout(historyUrl);    \r\n}\r\n```\r\n\r\nИ не забываем заменить способ загрузки приложения, теперь мы передаем наши роуты routes и описание приложения State в функцию HTMLixRouter().\r\n```javascript\r\nwindow.onload = function(){\r\n\r\n\t///создаем экземпляр  HTMLix\r\n\tvar HM = HTMLixRouter(State, routes);\r\n\t\t\r\n        var url = window.location.pathname;\r\n\t\t\r\n\t    if(window.location.pathname == \"/\"){\r\n\t\t\t\r\n\t\turl = url+\"json\";\r\n\t\t\t\r\n\t    }else{\r\n\t\t\t\r\n\t\t url = url + \"/json\";\r\n\t    }\t\r\n          \r\n          //отправляем запрос чтобы загрузить массив со всеми карточками товара при первой загрузке приложения\t\r\n\t  HM.stateMethods.fetchCategoryCarts(url, function(arr){  HM.stateProperties.carts = arr; });\r\n\t  console.log(HM);\r\n}\r\n```\r\nНу вот теперь наше приложение работает для трех адресов url, за исключением смены варианта шаблона для `single_cart` и клика по категории из `single_cart`. Давайте покликаем посмотрим что все в порядке.\r\n\r\nДалее давайте создадим два новых компонента в описании приложения - для смены варианта шаблона в компоненте single cart:\r\n\r\n``` \r\n\tcart_variant_option: {\r\n\t\tcontainer: \"cart_variant_option\", // views/twig_templates/  data-cart_variant_option=\"container\"\r\n\r\n\t\tprops: [\"click\", \"select\"],  //data-cart_variant_option-select=\"select\" , data-cart_variant_option-click=\"click\"\r\n\t\tmethods: { \r\n\t\t\t\tclick: function(){\r\n\t\t\t\t\t\r\n\t\t\t\t\tconsole.log(this.parent.props.select.getProp());\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t},\r\n\tcart_variant_radio: {\r\n\t\tselector: \"div:last-of-type\",\r\n\t\tcontainer: \"cart_variant_radio_cont\",\r\n\t\tprops: [\"click\", \"radio\"],\r\n\t\tmethods: { \r\n\t\t\t\r\n\t\t\t\tclick: function(){\r\n\t\t\t\t\t\r\n\t\t\t\t\tconsole.log(this.parent.index+\" --- \"+this.parent.props.radio.getProp());\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t},\r\n\r\n```\r\nПосле чего раскомментируем свойство `variant_tmpl` компонента - контейнера `cart_single`\r\n  \r\n```\r\ncart_single: {\r\n   container: \"cart_single\",\r\n   props: [\"variant_tmpl\"\r\n\r\n```\r\n  \r\nИ в методе `listner_click_on_cart`:\r\n\r\n```\r\n\t\tvar props = {\r\n\t\t\t\t\t\t\t\r\n\t\t   title: cart.title,\r\n\t\t   title_category: cart.titleCategory,\r\n\t\t   cost: cart.cost,\r\n\t\t   src_img: '/static/upload/'+cart.image,\r\n\t\t   data: cart.category,\r\n\t\t   description:  cart.description,\r\n\t\t   cost_btn: cart.cost,\r\n\t\t   manufacture: cart.manufacture,\r\n\t\t   variant_tmpl: cart.variant_tmpl, //раскомментировали\r\n\t\t\t\t\t\t\t\r\n\t\t }\r\n```\r\n\r\nТеперь при клике на карточку товара, в разных категориях товара у нас будет разный шаблон, а в свойстве variant_tmpl один из двух компонентов  `cart_variant_radio` - ноутбуки и телевизоры `cart_variant_option` - фотоаппараты.\r\n\r\nДалее давайте добавим код в метод `click_category` компонента - контейнера `cart_single` чтобы при клике по категории из нутри карточки товара у нас также менялась активная категория и изменялся отображаемый в роутере компонент, просто скопируем код из метода click контейнера category - компонента categories.\r\n\r\n```\r\nclick_category: function(){\r\n\t\t\t\t\t\t\t\t\r\n\t   event.preventDefault();\t\t\t\t\r\n\t    this.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(this.parent.props.data.getProp());\r\n\t    \r\n           var historyUrl = \"/category/\"+this.parent.props.data.getProp();\r\n\t    var url = historyUrl+\"/json\";\t\t\t\t\r\n           \r\n           this.rootLink.stateMethods.load_carts(url, this);\r\n\t   this.rootLink.router.setRout(historyUrl);\t\t\t\t\t\t\t\t\r\n},\r\n```\r\nИтак метод работает но плохо то что мы продублировали код давайте перенесем весь код в метод `click_on_category` в объект с общими методами для всего приложения stateMethods, и предадим в него context параметром, а вторым url который хотим сменить:\r\n\r\n```\r\nclick_on_category: function(context, event){\r\n\t\t\t\t\r\n\tevent.preventDefault();\t\t\t\t\r\n\t\t\t\t\r\n\tvar historyUrl = \"/category/\"+context.parent.props.data.getProp();\r\n\tvar url = historyUrl+\"/json\";\r\n\t\t\t\t\r\n\tcontext.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(context.parent.props.data.getProp());\r\n\t\t\t\t\r\n\tcontext.rootLink.router.setRout(historyUrl);\r\n\t\t\t\tconsole.log(url);\r\n\tcontext.rootLink.stateMethods.load_carts(url, context);\r\n\t\t\t\t\r\n},\r\n```\r\nА в методе `click_category` компонента - контейнера `cart_single` и методе `click` контейнера category компонента categories вызовем общий метод: \r\n```\r\n/* */ : function(){\r\n\r\n     this.rootLink.stateMethods.click_on_category(this, event);\r\n} \t\r\n```\r\n\r\nИтак мы создали первую часть прототипа интернет магазина для трех адресов url, в следующем уроке создадим остальное, полный скрипт приложения до этой точки приведен ниже, на этом пока что все.\r\n\r\n\r\n```\r\n\r\nvar State = {\r\n\t\r\n  categories: {\r\n    container: \"category\", \r\n    //добавили слушателя события \"emiter-click-on-category\"\r\n    props: [ \"data\", \"click\", 'class', \"title\",  ['listner_click_on_category', \"emiter-click-on-category\", \"\"]],\r\n    methods: {\r\n\tclick: function(){\r\n\t\t\r\n\t\t\tthis.rootLink.stateMethods.click_on_category(this, event);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t},\r\n\tlistner_click_on_category: function(){ \r\n\t//в слушателе события клика по категории удаляем класс \"active\" со всех контейнеров\r\n\t// затем устанавливаем его на контейнере данные свойства data которого совпадают\r\n        // с данными переданyыми в событие \"emiter-click-on-category\"\r\n\t\t\t\t\r\n\t\tthis.parent.props.class.removeProp(\"active\");\r\n\t\t\t\t\r\n\t\tif(this.parent.props.data.getProp() == this.emiter.prop){\t\t\t\t\t\r\n\t\t  this.parent.props.class.setProp(\"active\");\r\n\t\t}\t\t\t\t\r\n\t},\r\n      }\t\t\r\n    },\r\n    carts: {\r\n\t\t//добавили свойство для компонента - массива carts\r\n\t\tarrayProps: [ ['listener_load_carts', \"emiter-load-carts\", \"\"] ],\r\n\t\tarrayMethods: { \r\n\t\t\r\n\t\t  listener_load_carts: function(){ //слушаем событие \"emiter-load-carts\"\r\n\t\t\t\t\r\n\t\t\t\t\tthis.parent.removeAll(); //очищаем массив\r\n\t\t\t\r\n\t\t\t\t\tfor(var i=0; i<this.emiter.prop.length; i++){\r\n\t\t\t\t\t//в цикле перебераем полученый массив с карточками товара\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar prop = this.emiter.prop[i];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar props = { //создаем объект со всеми свойствами для контейнера cart\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\ttitle: prop.title,\r\n\t\t\t\t\t\t\ttitle_category: prop.titleCategory,\r\n\t\t\t\t\t\t\tcost: prop.cost,\r\n\t\t\t\t\t\t\tsrc_img: '/static/upload/'+prop.image,\r\n\t\t\t\t\t\t\tdata: \"/cart/\"+prop._id\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.parent.add(props); //добавляем новый контейнер передав в него начальные данные для свойств\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontainer: \"cart\",\r\n\t\t//добавили все свойства для контейнера cart\r\n\t\tprops: ['title', \"title_category\",  \"cost\", \"click\", \"src_img\", \"data\"  ],\r\n\t\tmethods: {\r\n\t\t\t\tclick: function(){ //метод для обработки кликов по карточке товара, \r\n\t\t\t\t                    //пока что просто выводит url карточки в консоль\r\n\t\t\t\t\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\r\n\t\t\t\t\tvar url = this.parent.props.data.getProp();\r\n\t\t\t\t\r\n\t\t\t\t\tconsole.log(url);\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.rootLink.router.setRout(url);\r\n\t\t\t\t    this.rootLink.eventProps[\"emiter-click-on-cart\"].setEventProp(this.parent.index);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t    }\t\t\r\n     },\r\ncart_single: {\r\n   container: \"cart_single\",\r\n   props: [\"variant_tmpl\",'title', \"title_category\", \"manufacture\", \"cost\", \"description\", \"cost_btn\", \"src_img\", [\"listner_click_on_cart\", \"emiter-click-on-cart\", \"\"], \"click_category\", \"data\"],\r\n   methods: {\r\n\t\t\t\r\n\tlistner_click_on_cart: function(){\r\n\t\t\t\t\r\n\t\tvar index = this.emiter.getEventProp(); \r\n                 //получаем индекс контейнера карточки по которой кликнули в компоненте carts\r\n\r\n\t\tvar cart = this.rootLink.stateProperties.carts[index];\r\n                //выбираем из загруженных раннее в массиве карточек нужную нам по индексу контейнера \r\n\t\t\t\t\r\n\t\tvar props = {\r\n\t\t\t\t\t\t\t\r\n\t\t   title: cart.title,\r\n\t\t   title_category: cart.titleCategory,\r\n\t\t   cost: cart.cost,\r\n\t\t   src_img: '/static/upload/'+cart.image,\r\n\t\t   data: cart.category,\r\n\t\t   description:  cart.description,\r\n\t\t   cost_btn: cart.cost,\r\n\t\t   manufacture: cart.manufacture,\r\n\t\t  variant_tmpl: cart.variant_tmpl, //пока что закоментируем установку варианта шаблона, т.к. мы еще не создали компоненты для них.\r\n\t\t\t\t\t\t\t\r\n\t\t }\r\n\t\t\t\t\t\t\r\n\t\tthis.parent.setAllProps(props);\r\n \t        //устанавливаем новые значения сразу для всех свойств, с помощью метода setAllProps(props);\t\t\t\t\t\r\n\t},\r\n   click_category: function(){\r\n\t\t\t\t\t\t\t\t\r\nthis.rootLink.stateMethods.click_on_category(this, event);\r\n\t\t\t\t\t\t\t\r\n    },\t\r\n},\r\n},\r\ncart_variant_option: {\r\n\t\tcontainer: \"cart_variant_option\", // views/twig_templates/  data-cart_variant_option=\"container\"\r\n\r\n\t\tprops: [\"click\", \"select\"],  //data-cart_variant_option-select=\"select\" , data-cart_variant_option-click=\"click\"\r\n\t\tmethods: { \r\n\t\t\t\tclick: function(){\r\n\t\t\t\t\t\r\n\t\t\t\t\tconsole.log(this.parent.props.select.getProp());\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t\r\n},\r\ncart_variant_radio: {\r\n\t\tselector: \"div:last-of-type\",\r\n\t\tcontainer: \"cart_variant_radio_cont\",\r\n\t\tprops: [\"click\", \"radio\"],\r\n\t\tmethods: { \r\n\t\t\t\r\n\t\t\t\tclick: function(){\r\n\t\t\t\t\t\r\n\t\t\t\t\tconsole.log(this.parent.index+\" --- \"+this.parent.props.radio.getProp());\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t}\r\n\t\t\r\n},\r\n     stateProperties:{ //объект для хранения общих переменных приложения\t\t\r\n\tcarts: [],\t\t\r\n     },\r\n     stateMethods: {\r\n\t   click_on_category: function(context, event){\r\n\t\t\t\t\r\n\t\t\tevent.preventDefault();\t\t\t\t\r\n\t\t\t\t\r\n\t\t\tvar historyUrl = \"/category/\"+context.parent.props.data.getProp();\r\n\t\t\tvar url = historyUrl+\"/json\";\r\n\t\t\t\t\r\n\t\t\tcontext.rootLink.eventProps[\"emiter-click-on-category\"].setEventProp(context.parent.props.data.getProp());\r\n\t\t\t\t\r\n\t\t\tcontext.rootLink.router.setRout(historyUrl);\r\n\t\t\t\tconsole.log(url);\r\n\t\t\tcontext.rootLink.stateMethods.load_carts(url, context);\r\n\t\t\t\t\r\n\t},\r\n\tfetchCategoryCarts: function(url, callb){ \r\n\t// общий  метод для загрузки данных с какого либо адреса get запросм, \r\n       //принимает в параметрах адрес - url и функцию обратного вызова callb в которую он передаст полученые данные \r\n\t\t\t\t\t\r\n\t   fetch(url).then((response) => {\r\n\t\tif(response.ok) {\r\n\t\t   return response.json();\r\n\t\t}\t          \r\n\t\t  throw new Error('Network response was not ok');\r\n\t    }).then((json) => {\r\n\t\tcallb(json); \r\n            }).catch((error) => {\r\n\t\t console.log(error);\r\n\t     });\t\r\n\t}, \r\n\tload_carts:  function(url, context ){ \r\n\t//метод вызывает fetchCategoryCarts передавая в него функцию обратного вызова \r\n\t// в которой подставляем данные с сервера в переменную .carts\r\n\t//в дальнейшем также будем вызывать событие \"emiter-load-carts\" которое мы еще не создали\r\n\r\n\t   context.rootLink.stateMethods.fetchCategoryCarts(url, function(data){\r\n\t\t\t\t\t\r\n\t       context.rootLink.stateProperties.carts = data;\r\n\t\t\t\t\t\r\n\t       console.log(data)\r\n\t      context.rootLink.eventProps[\"emiter-load-carts\"].setEventProp(data);\t\t\t\t\r\n\t\t\t\t\t\r\n\t    });\r\n\t},\r\n\r\n     },\r\n     eventEmiters: {//создали объект со всеми пользовательскими событиями\r\n\t \r\n\t \t [\"emiter-click-on-cart\"]: {\r\n\t\t\t\r\n\t\t\tprop: \"\",\r\n\t\t},\t\t \r\n        [\"emiter-click-on-category\"] : { //добавили событие \"emiter-click-on-category\"\t\t\t\t\r\n\t\tprop: [],\t\t\t\t\r\n\t   },\r\n\t   [\"emiter-load-carts\"]: {\r\n\t\t\t\r\n\t\t\tprop: \"\",\r\n\t\t}\r\n      }\t\t\r\n}\r\n\r\nvar routes = {\r\n\t\r\n    [\"/\"]: {\t\t\r\n        first: [\"categories\", 'carts'],  /// компоненты которые есть в html файле указываются в этом массиве, остальные будут загружены с шаблона, в fetch запросе асинхронно\r\n\r\n\troutComponent: { \r\n                router_carts: \"carts\", //компонент соответствующий данному роуту\r\n           }, \r\n\t\ttemplatePath: \"/static/templates/index.html\" // папка для загрузки шаблонов\r\n     },\t\t\t\r\n     [\"/category/:idCategory\"]: {  //знак `:` говорит что это параметр, и с ним сравненние не требуется, проверяется только его наличие, еще есть знак `*` в конце слова например если у нас category1, category2, и т.д то ставим звездочку в конце category*.\r\n\t\t\r\n\t first: [\"categories\", 'carts', \"menu\", \"home_page\"], \r\n\r\n\t routComponent: {\t\t\t\r\n\t         router_carts: \"carts\",\t\t\t\r\n\t\t}, \r\n\t  templatePath: \"/static/templates/index.html\" \r\n\t},\t\r\n     [\"/cart/:idCart\"]: { \r\n\t\t\r\n\t  first: [\"categories\", 'cart_single'], \r\n\r\n\t  routComponent: {\r\n\t       router_carts: \"cart_single\",\t\t\t\r\n\t   },\r\n\t   templatePath: \"/static/templates/index.html\"\r\n      },\r\n}\r\n\r\n\twindow.onload = function(){\r\n\t\t\t///создаем экземпляр  HTMLix\r\n\t\t\t\r\n\t\tvar HM = HTMLixRouter(State, routes);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tvar url = window.location.pathname;\r\n\t\t\r\n\t\tif(window.location.pathname == \"/\"){\r\n\t\t\t\r\n\t\t\turl = url+\"json\";\r\n\t\t\t\r\n\t\t}else{\r\n\t\t\t\r\n\t\t\turl = url + \"/json\";\r\n\t\t}\r\n\t\t\r\n\t\tHM.stateMethods.fetchCategoryCarts(url, function(arr){  HM.stateProperties.carts = arr; });\r\n\t\t\r\n\t\tconsole.log(HM);\r\n\t}\r\n\r\n```\r\n"
}